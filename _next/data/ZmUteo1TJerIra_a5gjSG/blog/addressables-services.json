{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unity has great asset management system in a form of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Addressables\"), \", but to properly leverage all its functionality there is a need for a robust wrapper that carefully handles all operations with proper exceptions reporting and resources cleanup. Here is my reasoning behind creating that kind of wrapper.\"), mdx(\"h1\", {\n    \"id\": \"why\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#why\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Why?\"), mdx(\"p\", null, \"There are a lot of things to take care of when working with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Addressables\"), \":\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Checking \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AsyncOperationHandle\"), \" statuses.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Releasing \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AsyncOperationHandle\"), \" on operation success/failure.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Working with morally deprecated (IMHO) Event-based Asynchronous Pattern that can potentially lead to callback hell.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Working with modern and shiny Task-based Asynchronous Pattern that has its own share of problems when working with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Addressables\"), \":\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"try catch\"), \" blocks around \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AsyncOperationHandle.Task\"), \" does not catch exceptions, you still have to manually check \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AsyncOperationHandle.Status\"), \" and throw \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AsyncOperationHandle.OperationException\"), \":\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"try\\n{\\nvar asyncOp = Addressables.LoadAssetAsync<Sprite>(InvalidSpriteAssetReference);\\nSprite result = await asyncOp.Task;\\n}\\n//If any error occurs during async operation it won't be caught by catch block\\ncatch (Exception e)\\n{\\nDebug.LogError($\\\"Error during asset loading: {e}\\\");\\n}\\n\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Addressables\"), \" profiler events sending is enabled there always will be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UnityException\"), \" when awaiting \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AsyncOperationHandle.Task\"), \" (dunno why, btw).\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No compile-time type safety when using some of the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Addressables\"), \" API. For example, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Addressables.LoadAssetAsync<Sprite>(AssetKey)\"), \" expects \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"object\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IResourceLocation\"), \" as its argument, but there is absolutely no guarantee that there will \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Sprite\"), \" by that asset key.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Managing resources reference counts. It seems like pretty easy task, but ensuring that all unused assets are unloaded automatically by relying on \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Addressables\"), \" reference-counting can become daunting work when assets are loaded from here and there during application lifecycle.\")), mdx(\"h1\", {\n    \"id\": \"how\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#how\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"How?\"), mdx(\"p\", null, \"I wanted to create a wrapper for most common \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Addressables\"), \" operations that solves aforementioned problems. Here are my main goals:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"async/await\"), \" workflow with proper structured exception handling.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This was achieved by using \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/Cysharp/UniTask\"\n  }), \"UniTask\"), \" package. There is a way to solve this without reliance on the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UniTask\"), \", but I don't feel like reinventing the wheel, because \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UniTask\"), \" does exactly what I need. Also, with some performance benefits because of the reduced memory allocation for tasks.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Compile-time type safety using \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AssetReference<T>\"), \" for the asset loading operations.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Providing generic \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IAddressablesLoader<T>\"), \" that accepts \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"AssetReference<T>\"), \" only of the same type constraint as its arguments.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Ensuring resources are properly loaded and unloaded after they are not needed by separating resources management in two phases:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Preload phase: preload and hold all required resources in \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IAddressablesLoader<T>\"), \" instance. Use them in sync way during gameplay. It is also possible to load necessary resources whenever you need, but it is better to cleanly define entry point where everything is prepared beforehand.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unload phase: release and loaded or individual resources from \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IAddressablesLoader<T>\"), \", e.g. when switching to another \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Scene\"), \" with different set of required assets.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No need to worry about ref-counts since all references are concentrated in one place and it is impossible to load something twice or use asset that was not preloaded before.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Project independence. Package can be used in almost any projects, it has a small codebase with possibility to extend it further when needs arise.\")), mdx(\"h2\", {\n    \"id\": \"result\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#result\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Result\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dre0dru/AddressablesServices\"\n  }), \"Addressables Services\"), \" is the open-source Unity package that provides essential functionality for worry-free usage of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Addressables\"), \" in safe and predictable manner.\"), mdx(\"p\", null, \"You can read more about usage and installation on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dre0dru/AddressablesServices\"\n  }), \"GitHub\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Unity has great asset management system in a form of <code>Addressables</code>, but to properly leverage all its functionality there is a need for a robust wrapper that carefully handles all operations with proper exceptions reporting and resources cleanup. Here is my reasoning behind creating that kind of wrapper.</p><h1 id=\"why\"><a href=\"#why\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Why?</h1><p>There are a lot of things to take care of when working with <code>Addressables</code>:</p><ul><li>Checking <code>AsyncOperationHandle</code> statuses.</li><li>Releasing <code>AsyncOperationHandle</code> on operation success/failure.</li><li>Working with morally deprecated (IMHO) Event-based Asynchronous Pattern that can potentially lead to callback hell.</li><li>Working with modern and shiny Task-based Asynchronous Pattern that has its own share of problems when working with <code>Addressables</code>:<ul><li><code>try catch</code> blocks around <code>AsyncOperationHandle.Task</code> does not catch exceptions, you still have to manually check <code>AsyncOperationHandle.Status</code> and throw <code>AsyncOperationHandle.OperationException</code>:</li></ul><pre><code>try\n{\nvar asyncOp = Addressables.LoadAssetAsync&lt;Sprite&gt;(InvalidSpriteAssetReference);\nSprite result = await asyncOp.Task;\n}\n//If any error occurs during async operation it won&#x27;t be caught by catch block\ncatch (Exception e)\n{\nDebug.LogError($&quot;Error during asset loading: {e}&quot;);\n}\n</code></pre><ul><li>When <code>Addressables</code> profiler events sending is enabled there always will be <code>UnityException</code> when awaiting <code>AsyncOperationHandle.Task</code> (dunno why, btw).</li></ul></li><li>No compile-time type safety when using some of the <code>Addressables</code> API. For example, <code>Addressables.LoadAssetAsync&lt;Sprite&gt;(AssetKey)</code> expects <code>object</code> or <code>IResourceLocation</code> as its argument, but there is absolutely no guarantee that there will <code>Sprite</code> by that asset key.</li><li>Managing resources reference counts. It seems like pretty easy task, but ensuring that all unused assets are unloaded automatically by relying on <code>Addressables</code> reference-counting can become daunting work when assets are loaded from here and there during application lifecycle.</li></ul><h1 id=\"how\"><a href=\"#how\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>How?</h1><p>I wanted to create a wrapper for most common <code>Addressables</code> operations that solves aforementioned problems. Here are my main goals:</p><ul><li><code>async/await</code> workflow with proper structured exception handling.<ul><li>This was achieved by using <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/Cysharp/UniTask\">UniTask</a> package. There is a way to solve this without reliance on the <code>UniTask</code>, but I don&#x27;t feel like reinventing the wheel, because <code>UniTask</code> does exactly what I need. Also, with some performance benefits because of the reduced memory allocation for tasks.</li></ul></li><li>Compile-time type safety using <code>AssetReference&lt;T&gt;</code> for the asset loading operations.<ul><li>Providing generic <code>IAddressablesLoader&lt;T&gt;</code> that accepts <code>AssetReference&lt;T&gt;</code> only of the same type constraint as its arguments.</li></ul></li><li>Ensuring resources are properly loaded and unloaded after they are not needed by separating resources management in two phases:<ul><li>Preload phase: preload and hold all required resources in <code>IAddressablesLoader&lt;T&gt;</code> instance. Use them in sync way during gameplay. It is also possible to load necessary resources whenever you need, but it is better to cleanly define entry point where everything is prepared beforehand.</li><li>Unload phase: release and loaded or individual resources from <code>IAddressablesLoader&lt;T&gt;</code>, e.g. when switching to another <code>Scene</code> with different set of required assets.</li><li>No need to worry about ref-counts since all references are concentrated in one place and it is impossible to load something twice or use asset that was not preloaded before.</li></ul></li><li>Project independence. Package can be used in almost any projects, it has a small codebase with possibility to extend it further when needs arise.</li></ul><h2 id=\"result\"><a href=\"#result\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Result</h2><p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/dre0dru/AddressablesServices\">Addressables Services</a> is the open-source Unity package that provides essential functionality for worry-free usage of <code>Addressables</code> in safe and predictable manner.</p><p>You can read more about usage and installation on <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/dre0dru/AddressablesServices\">GitHub</a>.</p>","scope":{}},"frontMatter":{"wordCount":546,"readingTime":{"text":"3 min read","minutes":2.72,"time":163200.00000000003,"words":544},"slug":"addressables-services","fileName":"addressables-services.md","title":"Addressables Services for the async/await workflow with UniTask","date":"2021-04-03","tags":["Unity","Addressables","UniTask"],"draft":false,"summary":"Unity has great asset management system in a form of Addressables, but to properly leverage all its functionality there is a need for a robust wrapper that carefully handles all operations with proper exceptions reporting and resources cleanup. Here is my reasoning behind creating that kind of wrapper.","images":[]}},"prev":{"title":"Tu-144","date":"2021-03-30","tags":["portfolio"],"draft":false,"summary":"An interactive museum inside legendary supersonic aircraft.","images":[],"slug":"tu-144"},"next":null},"__N_SSG":true}