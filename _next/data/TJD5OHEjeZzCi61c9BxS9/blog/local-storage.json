{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Sometimes there is a need arises for saving data locally on a device, be it server data caching, managing game progress for offline games, or storing user preferences. First, you write necessary data in plain text, then you switch to JSON for readability, after that you want to protect your files from curious users. Next time you notice that your data takes too much space on a device, so you want to compress your data. The improvement process can go indefinitely, so here is my take on solving that kind of problems.\"), mdx(\"h1\", {\n    \"id\": \"why\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#why\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Why?\"), mdx(\"p\", null, \"My first attempt was the creation of an inheritance hierarchy where each next inheritor will override data processing (serialization/deserialization) methods with calling base class implementations. E.g, base \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonStorage\"), \" class, that uses Unity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonUtility\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EncryptedJsonStorage\"), \" that encrypts resulting JSON. But then I needed to change JSON serialization to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NewtonSoftJson\"), \". I had to create two new classes: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NewtonSoftJsonStorage\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EncryptedNewtonSoftJsonStorage\"), \" essentially copy-pasting most of the code and changing only a few lines. It doesn't sound like an extendable and maintainable set of classes.\"), mdx(\"h1\", {\n    \"id\": \"how\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#how\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"How?\"), mdx(\"p\", null, \"Since inheritance doesn't work, what options do we have? Composition, and to be more precise - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decorator\"), \" pattern. The basic idea is following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Separate and abstract three processes: serialization/deserialization, saving/loading and data transformation.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ISerializationProvider\"), \" for serialization and deserialization. It can be any format that suits one's need, e.g. plain text, JSON, binary, XML.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IDataTransform\"), \" for applying optional data transformations during serialization/deserialization, e.g. data encryption or compression.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IFileStorage\"), \" with for saving and loading data to disk on device.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IPlayerPrefsStorage\"), \" for saving and loading data to \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.unity3d.com/ScriptReference/PlayerPrefs.html\"\n  }), \"Unity\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PlayerPrefs\"), \".\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IFileStorage\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IPlayerPrefsStorage\"), \" are just \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"facade\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ISerializationProvider\"), \" with few utility methods corresponding their purpose:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IFileStorage\"), \" provides API for working with file system on device.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IPlayerPrefsStorage\"), \" provides API for working with \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PlayerPrefs\"), \". Basically, it mirrors \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PlayerPrefs\"), \" API, but adds ability to save generic data to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"PlayerPrefs\"), \" without need to manually convert it to string representation.\")))), mdx(\"p\", null, \"My main inspiration was how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Stream\"), \" API implemented in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c#\"), \" where some streams will use underlying streams passed in its constructor.\"), mdx(\"h2\", {\n    \"id\": \"result\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#result\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Result\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dre0dru/LocalStorage\"\n  }), \"Local Storage\"), \" is the open-source Unity package that provides a set of classes for working with local data on device including data encryption and compression.\"), mdx(\"p\", null, \"You can read more about usage and installation on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dre0dru/LocalStorage\"\n  }), \"GitHub\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Sometimes there is a need arises for saving data locally on a device, be it server data caching, managing game progress for offline games, or storing user preferences. First, you write necessary data in plain text, then you switch to JSON for readability, after that you want to protect your files from curious users. Next time you notice that your data takes too much space on a device, so you want to compress your data. The improvement process can go indefinitely, so here is my take on solving that kind of problems.</p><h1 id=\"why\"><a href=\"#why\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Why?</h1><p>My first attempt was the creation of an inheritance hierarchy where each next inheritor will override data processing (serialization/deserialization) methods with calling base class implementations. E.g, base <code>JsonStorage</code> class, that uses Unity <code>JsonUtility</code>, then <code>EncryptedJsonStorage</code> that encrypts resulting JSON. But then I needed to change JSON serialization to <code>NewtonSoftJson</code>. I had to create two new classes: <code>NewtonSoftJsonStorage</code> and <code>EncryptedNewtonSoftJsonStorage</code> essentially copy-pasting most of the code and changing only a few lines. It doesn&#x27;t sound like an extendable and maintainable set of classes.</p><h1 id=\"how\"><a href=\"#how\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>How?</h1><p>Since inheritance doesn&#x27;t work, what options do we have? Composition, and to be more precise - <code>decorator</code> pattern. The basic idea is following:</p><ul><li>Separate and abstract three processes: serialization/deserialization, saving/loading and data transformation.<ul><li><code>ISerializationProvider</code> for serialization and deserialization. It can be any format that suits one&#x27;s need, e.g. plain text, JSON, binary, XML.</li><li><code>IDataTransform</code> for applying optional data transformations during serialization/deserialization, e.g. data encryption or compression.</li><li><code>IFileStorage</code> with for saving and loading data to disk on device.</li><li><code>IPlayerPrefsStorage</code> for saving and loading data to <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://docs.unity3d.com/ScriptReference/PlayerPrefs.html\">Unity</a> <code>PlayerPrefs</code>.</li></ul></li><li><code>IFileStorage</code> and <code>IPlayerPrefsStorage</code> are just <code>facade</code> for <code>ISerializationProvider</code> with few utility methods corresponding their purpose:<ul><li><code>IFileStorage</code> provides API for working with file system on device.</li><li><code>IPlayerPrefsStorage</code> provides API for working with <code>PlayerPrefs</code>. Basically, it mirrors <code>PlayerPrefs</code> API, but adds ability to save generic data to <code>PlayerPrefs</code> without need to manually convert it to string representation.</li></ul></li></ul><p>My main inspiration was how <code>Stream</code> API implemented in <code>c#</code> where some streams will use underlying streams passed in its constructor.</p><h2 id=\"result\"><a href=\"#result\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Result</h2><p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/dre0dru/LocalStorage\">Local Storage</a> is the open-source Unity package that provides a set of classes for working with local data on device including data encryption and compression.</p><p>You can read more about usage and installation on <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/dre0dru/LocalStorage\">GitHub</a>.</p>","scope":{}},"frontMatter":{"wordCount":387,"readingTime":{"text":"2 min read","minutes":1.925,"time":115500,"words":385},"slug":"local-storage","fileName":"local-storage.md","title":"Local Storage - a set of utility classes for managing local data stored on device","date":"2021-05-08","tags":["Unity","Data Management"],"draft":false,"summary":"Sometimes there is a need arises for saving data locally on a device, be it server data caching, managing game progress for offline games, or storing user preferences. First, you write necessary data in plain text, then you switch to JSON for readability, after that you want to protect your files from curious users. Next time you notice that your data takes too much space on a device, so you want to compress your data. The improvement process can go indefinitely, so here is my take on solving that kind of problems.","images":[]}},"prev":{"title":"Addressables Services for the async/await workflow with UniTask","date":"2021-04-03","tags":["Unity","Addressables","UniTask"],"draft":false,"summary":"Unity has great asset management system in a form of Addressables, but to properly leverage all its functionality there is a need for a robust wrapper that carefully handles all operations with proper exceptions reporting and resources cleanup. Here is my reasoning behind creating that kind of wrapper.","images":[],"slug":"addressables-services"},"next":null},"__N_SSG":true}