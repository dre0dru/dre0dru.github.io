{"pageProps":{"post":{"mdxSource":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Sometimes there is a need arises for saving data locally on a device, be it server data caching, managing game progress for offline games, or storing user preferences. First, you write necessary data in plain text, then you switch to JSON for readability, after that you want to protect your files from curious users. Next time you notice that your data takes too much space on a device, so you want to compress your data. The improvement process can go indefinitely, so here is my take on solving that kind of problems.\"), mdx(\"h1\", {\n    \"id\": \"why\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#why\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Why?\"), mdx(\"p\", null, \"My first attempt was the creation of an inheritance hierarchy where each next inheritor will override data processing (serialization/deserialization) methods with calling base class implementations. E.g, base \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonStorage\"), \" class, that uses Unity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JsonUtility\"), \", then \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EncryptedJsonStorage\"), \" that encrypts resulting JSON. But then I needed to change JSON serialization to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NewtonSoftJson\"), \". I had to create two new classes: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NewtonSoftJsonStorage\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"EncryptedNewtonSoftJsonStorage\"), \" essentially copy-pasting most of the code and changing only a few lines. It doesn't sound like an extendable and maintainable set of classes.\"), mdx(\"h1\", {\n    \"id\": \"how\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h1\"\n  }, {\n    \"href\": \"#how\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"How?\"), mdx(\"p\", null, \"Since inheritance doesn't work, what options do we have? Composition, and to be more precise - decorator pattern. The basic idea is following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Separate and abstract two processes: serialization/deserialization and saving/loading.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ISerializationProvider\"), \" for serialization and deserialization. It can be any format that suits one's need, e.g. plain text, JSON, binary, XML.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IFileProvider\"), \" for saving and loading. Abstracting data read/write process to allow data preprocessing steps.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Create one generic class that can accept any combination of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ISerializationProvider\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IFileProvider\"), \" for managing data in a uniform way across the solution.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"IStorage\"), \" implementations that accept aforementioned interfaces in the constructor and use them for data saving/loading with few utility methods like deleting files and checking for existence.\")))), mdx(\"p\", null, \"My main inspiration was how \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Stream\"), \" API implemented in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"c#\"), \" where some streams will use underlying streams passed in its constructor.\"), mdx(\"h2\", {\n    \"id\": \"result\"\n  }, mdx(\"a\", _extends({\n    parentName: \"h2\"\n  }, {\n    \"href\": \"#result\",\n    \"aria-hidden\": \"true\",\n    \"tabIndex\": -1\n  }), mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"icon icon-link\"\n  }))), \"Result\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dre0dru/LocalStorage\"\n  }), \"Local Storage\"), \" is the open-source Unity package that provides a set of classes for working with local data on device including data encryption and compression.\"), mdx(\"p\", null, \"You can read more about usage and installation on \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/dre0dru/LocalStorage\"\n  }), \"GitHub\"), \".\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"<p>Sometimes there is a need arises for saving data locally on a device, be it server data caching, managing game progress for offline games, or storing user preferences. First, you write necessary data in plain text, then you switch to JSON for readability, after that you want to protect your files from curious users. Next time you notice that your data takes too much space on a device, so you want to compress your data. The improvement process can go indefinitely, so here is my take on solving that kind of problems.</p><h1 id=\"why\"><a href=\"#why\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Why?</h1><p>My first attempt was the creation of an inheritance hierarchy where each next inheritor will override data processing (serialization/deserialization) methods with calling base class implementations. E.g, base <code>JsonStorage</code> class, that uses Unity <code>JsonUtility</code>, then <code>EncryptedJsonStorage</code> that encrypts resulting JSON. But then I needed to change JSON serialization to <code>NewtonSoftJson</code>. I had to create two new classes: <code>NewtonSoftJsonStorage</code> and <code>EncryptedNewtonSoftJsonStorage</code> essentially copy-pasting most of the code and changing only a few lines. It doesn&#x27;t sound like an extendable and maintainable set of classes.</p><h1 id=\"how\"><a href=\"#how\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>How?</h1><p>Since inheritance doesn&#x27;t work, what options do we have? Composition, and to be more precise - decorator pattern. The basic idea is following:</p><ul><li>Separate and abstract two processes: serialization/deserialization and saving/loading.<ul><li><code>ISerializationProvider</code> for serialization and deserialization. It can be any format that suits one&#x27;s need, e.g. plain text, JSON, binary, XML.</li><li><code>IFileProvider</code> for saving and loading. Abstracting data read/write process to allow data preprocessing steps.</li></ul></li><li>Create one generic class that can accept any combination of <code>ISerializationProvider</code> and <code>IFileProvider</code> for managing data in a uniform way across the solution.<ul><li><code>IStorage</code> implementations that accept aforementioned interfaces in the constructor and use them for data saving/loading with few utility methods like deleting files and checking for existence.</li></ul></li></ul><p>My main inspiration was how <code>Stream</code> API implemented in <code>c#</code> where some streams will use underlying streams passed in its constructor.</p><h2 id=\"result\"><a href=\"#result\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Result</h2><p><a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/dre0dru/LocalStorage\">Local Storage</a> is the open-source Unity package that provides a set of classes for working with local data on device including data encryption and compression.</p><p>You can read more about usage and installation on <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/dre0dru/LocalStorage\">GitHub</a>.</p>","scope":{}},"frontMatter":{"wordCount":357,"readingTime":{"text":"2 min read","minutes":1.775,"time":106500,"words":355},"slug":"local-storage","fileName":"local-storage.md","title":"Local Storage - a set of utility classes for managing local data stored on device","date":"2021-05-08","tags":["Unity","Data Management"],"draft":false,"summary":"Sometimes there is a need arises for saving data locally on a device, be it server data caching, managing game progress for offline games, or storing user preferences. First, you write necessary data in plain text, then you switch to JSON for readability, after that you want to protect your files from curious users. Next time you notice that your data takes too much space on a device, so you want to compress your data. The improvement process can go indefinitely, so here is my take on solving that kind of problems.","images":[]}},"prev":{"title":"Addressables Services for the async/await workflow with UniTask","date":"2021-04-03","tags":["Unity","Addressables","UniTask"],"draft":false,"summary":"Unity has great asset management system in a form of Addressables, but to properly leverage all its functionality there is a need for a robust wrapper that carefully handles all operations with proper exceptions reporting and resources cleanup. Here is my reasoning behind creating that kind of wrapper.","images":[],"slug":"addressables-services"},"next":null},"__N_SSG":true}